diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6b327f5..cdee8ab 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -19,7 +19,8 @@ add_executable(episteme
     "${SRC}/chess/perft.cpp" 
     "${SRC}/chess/zobrist.cpp" 
     "${SRC}/evaluation/evaluate.cpp" 
-    "${SRC}/evaluation/nnue.cpp" 
+    "${SRC}/evaluation/nnue.cpp"
+    "${SRC}/search/movepick.cpp"
     "${SRC}/search/search.cpp" 
     "${SRC}/search/ttable.cpp"
     "${SRC}/uci/uci.cpp" 
diff --git a/src/search/search.cpp b/src/search/search.cpp
index 82781aa..22276aa 100755
--- a/src/search/search.cpp
+++ b/src/search/search.cpp
@@ -4,50 +4,6 @@
 namespace episteme::search {
     using namespace std::chrono;
 
-    void pick_move(ScoredList& scored_list, int start) {
-        const ScoredMove& start_move = scored_list.list(start);
-        for (size_t i = start + 1; i <  scored_list.count(); i++)    {
-            if (scored_list.list(i).mvv_lva > start_move.mvv_lva) {
-                scored_list.swap(start, i);
-            }
-        }
-    }
-
-    template<typename F>
-    ScoredList generate_scored_targets(const Position& position, F generator, bool include_quiets, const std::optional<tt::TTEntry>& tt_entry) {
-        MoveList move_list;
-        generator(move_list, position);
-        ScoredList scored_list;
-
-        for (size_t i = 0; i < move_list.count(); i++) {
-            Move move = move_list.list(i);
-            bool from_tt = tt_entry && include_quiets && tt_entry->move.data() == move.data();
-
-            PieceType src = piece_type(position.mailbox(sq_idx(move.from_square())));
-            PieceType dst = piece_type(position.mailbox(sq_idx(move.to_square())));
-            int src_val;
-            int dst_val;
-
-            bool is_capture = !include_quiets || dst != PieceType::None;
-
-            src_val = piece_vals[piece_type_idx(src)];
-            if(is_capture) {
-                dst_val = move.move_type() == MoveType::EnPassant ? piece_vals[piece_type_idx(PieceType::Pawn)] : piece_vals[piece_type_idx(dst)];
-            } else {
-                dst_val = 0;
-            }
-
-            int mvv_lva = (dst_val) ? dst_val * 10 - src_val : 0;
-
-            scored_list.add({
-                .move = move,
-                .mvv_lva = from_tt ? 1000 : mvv_lva
-            });
-        }
-
-        return scored_list;
-    }
-
     bool is_legal(const Position& position) {
         uint64_t kingBB = position.bitboard(piece_type_idx(PieceType::King)) & position.bitboard(color_idx(position.NTM()) + position.COLOR_OFFSET);
         return !is_square_attacked(sq_from_idx(std::countr_zero(kingBB)), position, position.STM());
diff --git a/src/search/search.h b/src/search/search.h
index 513b354..0af64b0 100644
--- a/src/search/search.h
+++ b/src/search/search.h
@@ -3,6 +3,7 @@
 #include "../chess/movegen.h"
 #include "../evaluation/evaluate.h"
 #include "ttable.h"
+#include "movepick.h"
 
 #include <cstdint>
 #include <chrono>
@@ -16,56 +17,6 @@ namespace episteme::search {
     constexpr int32_t INF = 99999999;
     constexpr int MAX_SEARCH_PLY = 256;
 
-    // BEGIN MOVEPICKING //
-
-    struct ScoredMove {
-        Move move;
-        int mvv_lva = 0;
-    };
-
-    class ScoredList {
-        public:
-            inline void add(const ScoredMove& move) {
-                the_list[the_count] = move;
-                the_count++;
-            }
-        
-            inline void clear() {
-                the_count = 0;
-            }
-        
-            [[nodiscard]] inline uint32_t count() const {
-                return the_count;
-            }
-        
-            [[nodiscard]] inline const ScoredMove list(int index) const {
-                return the_list[index];
-            }
-
-            inline void swap(int src_idx, int dst_idx) {
-                std::iter_swap(the_list.begin() + src_idx, the_list.begin() + dst_idx);
-            }
-
-        private:
-            std::array<ScoredMove, 256> the_list;
-            int the_count = 0;
-    };
-
-    template<typename F>
-    extern ScoredList generate_scored_targets(const Position& position, F generator, bool include_quiets, const std::optional<tt::TTEntry>& tt_entry = std::nullopt);
-
-    inline ScoredList generate_scored_moves(const Position& position, const tt::TTEntry& tt_entry) {
-        return generate_scored_targets(position, generate_all_moves, true, tt_entry);
-    }
-
-    inline ScoredList generate_scored_captures(const Position& position) {
-        return generate_scored_targets(position, generate_all_captures, false);
-    }
-
-    void pick_move(ScoredList& scored_list, int start);
-
-    // BEGIN SEARCH //
-
     struct Parameters {
         std::array<int32_t, 2> time = {};
         std::array<int32_t, 2> inc = {};
