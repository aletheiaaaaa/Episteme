diff --git a/diff.patch b/diff.patch
new file mode 100644
index 0000000..e69de29
diff --git a/src/chess/core.h b/src/chess/core.h
index 729cff7..9afa20e 100755
--- a/src/chess/core.h
+++ b/src/chess/core.h
@@ -6,7 +6,7 @@
 #include <array>
 
 namespace episteme {
-    constexpr std::array<int, 6> piece_vals = {1, 3, 3, 5, 9, -1}; 
+    constexpr std::array<int32_t, 6> piece_vals = {1, 3, 3, 5, 9, -1}; 
 
     constexpr uint8_t WHITE_KINGSIDE = 1;
     constexpr uint8_t WHITE_QUEENSIDE = 1 << 1;
diff --git a/src/search/search.cpp b/src/search/search.cpp
index d7805da..e775630 100755
--- a/src/search/search.cpp
+++ b/src/search/search.cpp
@@ -7,7 +7,7 @@ namespace episteme::search {
     using namespace std::chrono;
 
     void pick_move(ScoredList& scored_list, int start) {
-        for (size_t i = start + 1; i <  scored_list.count(); i++)    {
+        for (size_t i = start + 1; i < scored_list.count(); i++)    {
             if (scored_list.list(i).score > scored_list.list(start).score) {
                 scored_list.swap(start, i);
             }
@@ -46,10 +46,12 @@ namespace episteme::search {
         bool is_capture = dst != Piece::None || move.move_type() == MoveType::EnPassant;
 
         if (is_capture) {
-            int src_val = piece_vals[piece_type_idx(src)];
-            int dst_val = move.move_type() == MoveType::EnPassant ? piece_vals[piece_type_idx(PieceType::Pawn)] : piece_vals[piece_type_idx(dst)];
+            int32_t src_val = piece_vals[piece_type_idx(src)];
+            int32_t dst_val = move.move_type() == MoveType::EnPassant ? piece_vals[piece_type_idx(PieceType::Pawn)] : piece_vals[piece_type_idx(dst)];
 
             scored_move.score += dst_val * 10 - src_val + 100000;
+        } else {
+            scored_move.score += history.get_butterfly(position.STM(), move).value;
         }
 
         return scored_move;
@@ -83,6 +85,8 @@ namespace episteme::search {
             pick_move(move_list, i);
             Move move = move_list.list(i).move;
 
+            bool is_quiet = position.mailbox(sq_idx(move.to_square())) == Piece::None && move.move_type() != MoveType::EnPassant;
+
             accumulator = eval::update(position, move, accumulator);
             accum_history.emplace_back(accumulator);
             position.make_move(move);
@@ -120,6 +124,10 @@ namespace episteme::search {
                 PV.update_line(move, candidate);
 
                 if (score >= beta) {
+                    if (is_quiet && depth > 1) {
+                        history.update_butterfly(position.STM(), move, hist::history_bonus(depth));
+                    }
+
                     node_type = tt::NodeType::CutNode;
                     break;
                 }
@@ -292,6 +300,16 @@ namespace episteme::search {
         return report;
     }
 
+    int32_t Thread::eval(const Parameters& params) {
+        Line PV = {};
+
+        Position position = params.position;
+        accumulator = eval::reset(position);
+        accum_history.emplace_back(accumulator);
+
+        return search(position, PV, 0, 0, -INF, INF);
+    }
+
     void Thread::bench(int depth) {
         uint64_t total = 0;
         milliseconds elapsed = 0ms;
@@ -342,6 +360,10 @@ namespace episteme::search {
         std::cout << "bestmove " << best.to_string() << std::endl;
     }
 
+    void Instance::eval(const Parameters& params) {
+        std::cout << "info score cp " << thread.eval(params) << std::endl;
+    }
+
     void Instance::bench(int depth) {
         thread.bench(depth);
     }
diff --git a/src/search/search.h b/src/search/search.h
index fbb259b..eb390f4 100644
--- a/src/search/search.h
+++ b/src/search/search.h
@@ -3,6 +3,7 @@
 #include "../chess/movegen.h"
 #include "../evaluation/evaluate.h"
 #include "ttable.h"
+#include "history.h"
 
 #include <cstdint>
 #include <chrono>
@@ -21,7 +22,7 @@ namespace episteme::search {
 
     struct ScoredMove {
         Move move = {};
-        int score = 0;
+        int32_t score = 0;
     };
 
     class ScoredList {
@@ -122,6 +123,10 @@ namespace episteme::search {
         public:
             Thread(tt::Table& ttable) : ttable(ttable) {};
 
+            inline void reset_history() {
+                history.reset();
+            }
+
             ScoredMove score_move(const Position& position, const Move& move, const tt::Entry& tt_entry);
 
             template<typename F>
@@ -137,13 +142,17 @@ namespace episteme::search {
 
             int32_t search(Position& position, Line& PV, int16_t depth, int16_t ply, int32_t alpha, int32_t beta, SearchLimits limits);
             int32_t quiesce(Position& position, Line& PV, int16_t ply, int32_t alpha, int32_t beta, SearchLimits limits);
+
             ThreadReport run(const Parameters& params);
+            int32_t eval(const Parameters& params);
             void bench(int depth);
         private:
             nn::Accumulator accumulator;
             std::vector<nn::Accumulator> accum_history;
 
             tt::Table& ttable;
+            hist::Table history;
+
             uint64_t nodes;
     };
 
@@ -164,7 +173,12 @@ namespace episteme::search {
                 ttable.reset(size);
             }
 
+            inline void reset_history() {
+                thread.reset_history();
+            }
+
             void run();
+            void eval(const Parameters& params);
             void bench(int depth);
         private:
             tt::Table ttable;
diff --git a/src/uci/uci.cpp b/src/uci/uci.cpp
index 6854157..dc2657e 100644
--- a/src/uci/uci.cpp
+++ b/src/uci/uci.cpp
@@ -82,6 +82,7 @@ namespace episteme::uci {
             }
         }
 
+        instance.reset_history();
         instance.update_params(cfg.params);
         instance.run();
     }
@@ -89,12 +90,17 @@ namespace episteme::uci {
     auto ucinewgame(search::Config& cfg, search::Instance& instance) {
         cfg.params = {};
         instance.reset_tt();
+        instance.reset_history();
+    }
+    
+    auto eval(search::Config& cfg, search::Instance& instance) {
+        instance.eval(cfg.params);
     }
     
     auto bench(const std::string& args, search::Config& cfg) {
         int depth = (args.empty()) ? 4 : std::stoi(args);
         if (!cfg.hash_size) cfg.hash_size = 32;
-    
+
         search::Instance instance(cfg);
         instance.bench(depth);
     }
@@ -128,6 +134,8 @@ namespace episteme::uci {
             perft(arg, cfg);
         }
 
+        else if (keyword == "eval") eval(cfg, instance);
+
         else std::cout << "invalid command\n";
 
         return 0;
diff --git a/src/uci/uci.h b/src/uci/uci.h
index a4589e4..2000495 100644
--- a/src/uci/uci.h
+++ b/src/uci/uci.h
@@ -18,6 +18,7 @@ namespace episteme::uci {
     auto position(const std::string& args, search::Config& cfg);
     auto go(const std::string& args, search::Config& cfg, search::Instance& instance);
     auto ucinewgame(search::Config& cfg, search::Instance& instance);
+    auto eval(search::Config& cfg, search::Instance& instance);
     auto bench(const std::string& args, search::Config& cfg);
     auto perft(const std::string& args, search::Config& cfg);
 }
\ No newline at end of file
